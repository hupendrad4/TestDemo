generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Management
model User {
  id            String    @id @default(uuid())
  username      String    @unique
  email         String    @unique
  passwordHash  String
  firstName     String?
  lastName      String?
  role          UserRole  @default(TESTER)
  isActive      Boolean   @default(true)
  lastLoginAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  createdTestProjects    TestProject[]       @relation("ProjectCreator")
  createdTestCases       TestCase[]          @relation("TestCaseCreator")
  executedTests          TestExecution[]     @relation("TestExecutor")
  createdDefects         Defect[]            @relation("DefectReporter")
  assignedDefects        Defect[]            @relation("DefectAssignee")
  createdRequirements    Requirement[]       @relation("RequirementCreator")
  testPlanAssignments    TestPlanAssignment[]
  comments               Comment[]
  attachments            Attachment[]
  projectMemberships     ProjectMember[]

  @@map("users")
}

enum UserRole {
  ADMIN
  TEST_MANAGER
  TESTER
  DEVELOPER
  VIEWER
}

// Test Project Management
model TestProject {
  id                String    @id @default(uuid())
  name           String
  prefix         String    @unique
  description    String?
  isActive       Boolean   @default(true)
  isPublic       Boolean   @default(false)
  createdById    String
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  createdBy          User              @relation("ProjectCreator", fields: [createdById], references: [id])
  testSuites         TestSuite[]
  testPlans          TestPlan[]
  requirements       Requirement[]
  requirementSpecs   RequirementSpec[]
  customFields       CustomField[]
  integrations       Integration[]
  members            ProjectMember[]

  @@map("test_projects")
}

// Test Suite (Folder/Category)
model TestSuite {
  id                String    @id @default(uuid())
  name           String
  description    String?
  parentId       String?
  testProjectId  String
  orderIndex     Int       @default(0)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  testProject    TestProject   @relation(fields: [testProjectId], references: [id], onDelete: Cascade)
  parent         TestSuite?    @relation("TestSuiteHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children       TestSuite[]   @relation("TestSuiteHierarchy")
  testCases      TestCase[]

  @@map("test_suites")
}

// Test Case
model TestCase {
  id                 String            @id @default(uuid())
  externalId         String
  name               String
  summary            String?           @db.Text
  preconditions      String?           @db.Text
  testSuiteId        String
  createdById        String
  version            Int               @default(1)
  status             TestCaseStatus    @default(DRAFT)
  priority           Priority          @default(MEDIUM)
  executionType      ExecutionType     @default(MANUAL)
  estimatedTime      Int?              // in minutes
  isActive           Boolean           @default(true)
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt

  // Relations
  testSuite          TestSuite         @relation(fields: [testSuiteId], references: [id], onDelete: Cascade)
  createdBy          User              @relation("TestCaseCreator", fields: [createdById], references: [id])
  steps              TestStep[]
  keywords           TestCaseKeyword[]
  customFieldValues  CustomFieldValue[]
  testPlanCases      TestPlanCase[]
  requirements       TestCaseRequirement[]
  executions         TestExecution[]
  attachments        Attachment[]

  @@unique([testSuiteId, externalId])
  @@map("test_cases")
}

enum TestCaseStatus {
  DRAFT
  READY_FOR_REVIEW
  APPROVED
  DEPRECATED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ExecutionType {
  MANUAL
  AUTOMATED
}

// Test Step
model TestStep {
  id                String    @id @default(uuid())
  testCaseId        String
  stepNumber        Int
  action            String    @db.Text
  expectedResult    String    @db.Text
  testData          String?   @db.Text
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  testCase          TestCase  @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  stepExecutions    TestStepExecution[]

  @@unique([testCaseId, stepNumber])
  @@map("test_steps")
}

// Keywords/Tags
model Keyword {
  id          String            @id @default(uuid())
  name        String            @unique
  description String?
  createdAt   DateTime          @default(now())

  // Relations
  testCases   TestCaseKeyword[]

  @@map("keywords")
}

model TestCaseKeyword {
  testCaseId  String
  keywordId   String

  testCase    TestCase  @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  keyword     Keyword   @relation(fields: [keywordId], references: [id], onDelete: Cascade)

  @@id([testCaseId, keywordId])
  @@map("test_case_keywords")
}

// Test Plan Management
model TestPlan {
  id                String    @id @default(uuid())
  name              String
  description       String?   @db.Text
  testProjectId     String
  startDate         DateTime?
  endDate           DateTime?
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  testProject       TestProject           @relation(fields: [testProjectId], references: [id], onDelete: Cascade)
  builds            Build[]
  testCycles        TestCycle[]
  testPlanCases     TestPlanCase[]
  assignments       TestPlanAssignment[]

  @@map("test_plans")
}

// Build/Release
model Build {
  id              String    @id @default(uuid())
  name            String
  description     String?
  testPlanId      String
  releaseDate     DateTime?
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  testPlan        TestPlan        @relation(fields: [testPlanId], references: [id], onDelete: Cascade)
  executions      TestExecution[]

  @@map("builds")
}

// Test Cycle (Smoke, Sanity, Regression, etc.)
model TestCycle {
  id              String        @id @default(uuid())
  name            String
  type            TestCycleType
  description     String?
  testPlanId      String
  startDate       DateTime?
  endDate         DateTime?
  status          CycleStatus   @default(PLANNED)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  testPlan        TestPlan      @relation(fields: [testPlanId], references: [id], onDelete: Cascade)
  executions      TestExecution[]

  @@map("test_cycles")
}

enum TestCycleType {
  SMOKE
  SANITY
  REGRESSION
  INTEGRATION
  SYSTEM
  UAT
  CUSTOM
}

enum CycleStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Test Plan - Test Case Mapping
model TestPlanCase {
  id              String    @id @default(uuid())
  testPlanId      String
  testCaseId      String
  orderIndex      Int       @default(0)
  addedAt         DateTime  @default(now())

  // Relations
  testPlan        TestPlan  @relation(fields: [testPlanId], references: [id], onDelete: Cascade)
  testCase        TestCase  @relation(fields: [testCaseId], references: [id], onDelete: Cascade)

  @@unique([testPlanId, testCaseId])
  @@map("test_plan_cases")
}

// Test Plan Assignment to Users
model TestPlanAssignment {
  id              String    @id @default(uuid())
  testPlanId      String
  userId          String
  role            String    // "Lead", "Tester", "Reviewer"
  assignedAt      DateTime  @default(now())

  // Relations
  testPlan        TestPlan  @relation(fields: [testPlanId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([testPlanId, userId])
  @@map("test_plan_assignments")
}

// Test Execution
model TestExecution {
  id                String            @id @default(uuid())
  testCaseId        String
  testCycleId       String
  buildId           String
  executedById      String
  status            ExecutionStatus
  executionTime     Int?              // in minutes
  notes             String?           @db.Text
  executedAt        DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relations
  testCase          TestCase          @relation(fields: [testCaseId], references: [id])
  testCycle         TestCycle         @relation(fields: [testCycleId], references: [id])
  build             Build             @relation(fields: [buildId], references: [id])
  executedBy        User              @relation("TestExecutor", fields: [executedById], references: [id])
  stepExecutions    TestStepExecution[]
  defects           DefectExecution[]
  attachments       Attachment[]

  @@map("test_executions")
}

enum ExecutionStatus {
  PASSED
  FAILED
  BLOCKED
  NOT_RUN
  SKIPPED
}

// Test Step Execution
model TestStepExecution {
  id                String            @id @default(uuid())
  testExecutionId   String
  testStepId        String
  status            ExecutionStatus
  actualResult      String?           @db.Text
  notes             String?           @db.Text
  executedAt        DateTime          @default(now())

  // Relations
  testExecution     TestExecution     @relation(fields: [testExecutionId], references: [id], onDelete: Cascade)
  testStep          TestStep          @relation(fields: [testStepId], references: [id])

  @@map("test_step_executions")
}

// Requirements Management
model RequirementSpec {
  id                String        @id @default(uuid())
  name              String
  description       String?       @db.Text
  testProjectId     String
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  testProject       TestProject   @relation(fields: [testProjectId], references: [id], onDelete: Cascade)
  requirements      Requirement[]

  @@map("requirement_specs")
}

model Requirement {
  id                  String        @id @default(uuid())
  externalId          String
  title               String
  description         String?       @db.Text
  requirementSpecId   String
  testProjectId       String
  createdById         String
  status              ReqStatus     @default(DRAFT)
  priority            Priority      @default(MEDIUM)
  version             Int           @default(1)
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  // Relations
  requirementSpec     RequirementSpec @relation(fields: [requirementSpecId], references: [id], onDelete: Cascade)
  testProject         TestProject     @relation(fields: [testProjectId], references: [id], onDelete: Cascade)
  createdBy           User            @relation("RequirementCreator", fields: [createdById], references: [id])
  testCases           TestCaseRequirement[]

  @@unique([testProjectId, externalId])
  @@map("requirements")
}

enum ReqStatus {
  DRAFT
  APPROVED
  IMPLEMENTED
  DEPRECATED
}

model TestCaseRequirement {
  testCaseId      String
  requirementId   String
  linkedAt        DateTime  @default(now())

  testCase        TestCase    @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  requirement     Requirement @relation(fields: [requirementId], references: [id], onDelete: Cascade)

  @@id([testCaseId, requirementId])
  @@map("test_case_requirements")
}

// Defect Management
model Defect {
  id                String        @id @default(uuid())
  externalId        String        @unique
  title             String
  description       String        @db.Text
  reportedById      String
  assignedToId      String?
  status            DefectStatus  @default(OPEN)
  severity          Severity      @default(MEDIUM)
  priority          Priority      @default(MEDIUM)
  environment       String?
  stepsToReproduce  String?       @db.Text
  expectedBehavior  String?       @db.Text
  actualBehavior    String?       @db.Text
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  resolvedAt        DateTime?

  // Relations
  reportedBy        User              @relation("DefectReporter", fields: [reportedById], references: [id])
  assignedTo        User?             @relation("DefectAssignee", fields: [assignedToId], references: [id])
  executions        DefectExecution[]
  comments          Comment[]
  attachments       Attachment[]

  @@map("defects")
}

enum DefectStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  REOPEN
  REJECTED
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
  BLOCKER
}

model DefectExecution {
  defectId        String
  executionId     String
  linkedAt        DateTime  @default(now())

  defect          Defect        @relation(fields: [defectId], references: [id], onDelete: Cascade)
  execution       TestExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@id([defectId, executionId])
  @@map("defect_executions")
}

// Custom Fields
model CustomField {
  id                String              @id @default(uuid())
  name              String
  label             String
  fieldType         CustomFieldType
  testProjectId     String
  isRequired        Boolean             @default(false)
  defaultValue      String?
  possibleValues    Json?               // For select/radio/checkbox
  createdAt         DateTime            @default(now())

  // Relations
  testProject       TestProject         @relation(fields: [testProjectId], references: [id], onDelete: Cascade)
  values            CustomFieldValue[]

  @@unique([testProjectId, name])
  @@map("custom_fields")
}

enum CustomFieldType {
  TEXT
  TEXTAREA
  NUMBER
  DATE
  SELECT
  MULTISELECT
  CHECKBOX
  RADIO
}

model CustomFieldValue {
  id              String      @id @default(uuid())
  customFieldId   String
  testCaseId      String
  value           String      @db.Text

  // Relations
  customField     CustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)
  testCase        TestCase    @relation(fields: [testCaseId], references: [id], onDelete: Cascade)

  @@unique([customFieldId, testCaseId])
  @@map("custom_field_values")
}

// Comments
model Comment {
  id          String    @id @default(uuid())
  content     String    @db.Text
  defectId    String?
  userId      String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  defect      Defect?   @relation(fields: [defectId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id])

  @@map("comments")
}

// Attachments
model Attachment {
  id              String    @id @default(uuid())
  fileName        String
  originalName    String
  filePath        String
  fileSize        Int
  mimeType        String
  testCaseId      String?
  executionId     String?
  defectId        String?
  uploadedById    String
  uploadedAt      DateTime  @default(now())

  // Relations
  testCase        TestCase?       @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  execution       TestExecution?  @relation(fields: [executionId], references: [id], onDelete: Cascade)
  defect          Defect?         @relation(fields: [defectId], references: [id], onDelete: Cascade)
  uploadedBy      User            @relation(fields: [uploadedById], references: [id])

  @@map("attachments")
}

// Integrations
model Integration {
  id              String          @id @default(uuid())
  type            IntegrationType
  testProjectId   String
  config          Json            // Store integration-specific config
  isActive        Boolean         @default(true)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  testProject     TestProject     @relation(fields: [testProjectId], references: [id], onDelete: Cascade)

  @@unique([testProjectId, type])
  @@map("integrations")
}

enum IntegrationType {
  JIRA
  AZURE_DEVOPS
  GITHUB
  GITLAB
}

// Project Memberships (map users to projects)
model ProjectMember {
  id             String      @id @default(uuid())
  testProjectId  String
  userId         String
  role           String      @default("MEMBER")
  createdAt      DateTime    @default(now())

  // Relations
  testProject    TestProject @relation(fields: [testProjectId], references: [id], onDelete: Cascade)
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([testProjectId, userId])
  @@map("project_members")
}
